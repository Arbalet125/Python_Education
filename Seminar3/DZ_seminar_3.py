# Задайте список из нескольких чисел. Напишите программу, которая найдёт сумму элементов списка, стоящих на нечётной позиции.

# data = list(map(int,input("Введите числа для заполнения массива через пробел:\n".split())))
# lst = []
# if len(data) == 1:              # если строка с одним символом
#     print (data[0])             # печатаем первое число списка и все
# else:
#     for i in range(len(data)):
#         # if (i%2 == 1):        # выводится некрасиво, ибо для пользователя, счет начинается с первого элемента списка, а не с 0,
#         if (i%2 == 0):          # так что, для красоты вывода, лучше искать именно четные элементы списка
#             lst.append(data[i])
# print (f"Cумма нечетных элементов списка ", data, "равняется:", sum(lst))

###################################################################################

# Напишите программу, которая найдёт произведение пар чисел списка. Парой считаем первый и последний элемент, второй и предпоследний и т.д.


# def mult_lst(lst):
#     if len(lst) % 2 != 0:               # Сначала найдем длину для нового списка. Если список состоит из нечетного количества элементов
#         new_lst_leng = len(lst)//2 + 1  # длина нового списка будет равнятся: "половина длины исходного списка + 1"
#     else:                               # Если же количество элементов исходного списка четное,
#         new_lst_leng = len(lst)//2      # то длина нового списка равняется просто половине длины исходного списка.
#     for i in range(new_lst_leng):
#         new_lst = [lst[i]*lst[len(lst)-i-1]]
#     print(f"Произведение пар списка:\n", lst)
#     print(f"равняется: ", str(new_lst).strip('[').strip(']')) #долго мучился пытаясь сделать вывод без квадратных скобок :)
    
# lst = list(map(int, input("Введите числа для заполнения массива через пробел:\n").split()))
# mult_lst(lst)

###################################################################################

#Задайте список из вещественных чисел. Напишите программу, которая найдёт разницу между максимальным и минимальным значением дробной части элементов.

# lst = list(map(float, input("Введите числа для заполнения массива через запятую (числа могут быть вещественными, в качестве разделителя целой и дробной части используйте точку):\n").split(",")))
# new_lst = [round(i%1,2) for i in lst if i%1 != 0] # создаем новый массив, в котором оставляем максимум 2 числа после запятой, если эти числа не целые
# diff = max(new_lst) - min(new_lst)
# print()
# print (f"Разница между максимальным", max(new_lst), "и минимальным", min(new_lst), "элементами массива", lst, "равняется", diff)

###################################################################################

# Напишите программу, которая будет преобразовывать десятичное число в двоичное.

# s = "" # строка, а не число, которое мы будем добавлять в конце каждого преобразования, чтобы получить нужное нам число
# number = int(input("Введите число для преобразовывания десятичного числа в двоичное:\n"))
# fake_number = number
# while number != 0:
#     s = str(number%2) + s # к остатку добавляем предыдущее число, которое преобразовали в строчку. 
#     number //=2
# print()
# print(f"Двоичный вид числа {fake_number}\n", "Равняется:", s)

###################################################################################

# Задайте число. Составьте список чисел Фибоначчи, в том числе для отрицательных индексов.

# number = int(input('Введите число: '))

# def get_fibonacci(number):
#     fibon_numbers = []
#     a, b = 1, 1
#     for i in range(number-1):
#         fibon_numbers.append(a)
#         a, b = b, a + b
#     a, b = 0, 1
#     for i in range (number):
#         fibon_numbers.insert(0, a)
#         a, b = b, a - b
#     return fibon_numbers

# fibon_numbers = get_fibonacci(number)
# print(get_fibonacci(number))
# print(fibon_numbers.index(0))